% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/partition.R
\name{partition}
\alias{partition}
\alias{partition_dim}
\title{Divide a grid of cells into partitions containing individual tables}
\usage{
partition(cells, corners, position = "top_left",
  partition_name = "partition")

partition_dim(positions, cutpoints, bound = "upper")
}
\arguments{
\item{cells}{Data frame or tbl, the cells to be partitioned, from
\code{\link[=tidy_table]{tidy_table()}} or \code{\link[tidyxl:xlsx_cells]{tidyxl::xlsx_cells()}}.}

\item{corners}{a subset of \code{cells}, being the corners of individual tables.}

\item{position}{Character, the position of the corner cells relative to their
tables, one of \code{"top-left"} (default), \code{"top-right"}, \code{"bottom-left"},
\code{"bottom-right"}.
position or the column position), which are to be grouped between cutpoints.}

\item{partition_name}{Character vector length 1, what to call the new column
that will be created to identify the partitions.  Default: \code{"partition"}.}

\item{positions}{Integer vector, the positions of cells (either the row
position or the column position), which are to be grouped between cutpoints.}

\item{cutpoints}{Integer vector. The \code{positions} will be separated into
groups either side of each cutpoint.}

\item{bound}{One of \code{"upper"} or \code{"lower"}, controls whether cells that lie
on a cutpoint are should be grouped with cells below or above the cutpoint.
For example, if column 5 is a cutpoint, and a cell is in column 5, \code{"lower"}
would group it with cells in columns 1 to 4, whereas \code{"upper"} would group it
with cells in columns 6 to 10.  This is so that you can use cells at the
bottom or the right-hand side of a table as the cutpoints (either of which
would be 'upper' bounds because row and column numbers count from 1 in the
top-left row and column).  When \code{"upper"}, any \code{cell_positions} above the
first cutpoint will be in group 0; when \code{"lower"}, any \code{cell_positions} below
the final cutpoint will be 0.}
}
\value{
\code{partition_dim()} returns an integer vector, numbering the groups of
cells.  Group 0 represents the cells above the first cutpoint (when \code{bound = "upper"}), or below the first cutpoint (when \code{bound = "lower"}).  The other
groups are numbered from 1, where group 1 is adjacent to group 0.

\code{partition_dim()} returns an integer vector, numbering the groups of cells.
Group 0 represents the cells above the first cutpoint (when \code{bound = "upper"}), or below the first cutpoint (when \code{bound = "lower"}).  The other
groups are numbered from 1, where group 1 is adjacent to group 0.  Divide a
grid of cells into chunks along both dimensions
}
\description{
Given the positions of corner cells that mark individual tables
in a single spreadsheet, \code{partion()} works out which cells belong to which
tables, and gives them an ID.  This can be used with \code{dplyr::group_by()} or
\code{tidyr::nest()} to operate on each single table within a spreadsheet of
several tables.

Corners must all be in the top-left, or bottom-left, or top-right, or
bottom-right of each table.

\code{partition()} partitions along both dimensions (rows and columns) at once.
\code{partition_dim()} partitions along one dimension at a time.
}
\section{Functions}{
\itemize{
\item \code{partition_dim}: Divide a grid of cells into chunks along one dimension
}}

\examples{
# The `purpose` dataset, represented in four summary tables
multiples <- purpose$small_multiples
rectify(multiples, character, numeric)

# The same thing in its raw 'melted' form that can be filtered
multiples

# First, find the cells that mark a corner of each table
corners <-
  dplyr::filter(multiples,
                !is.na(character),
                !(character \%in\% c("Sex", "Value", "Female", "Male")))

# Then find out which cells fall into which partition
partition(multiples, corners)

# It's more obvious if you also split() by the new 'partition' column
x <- partition(multiples, corners)
split(x, x$partition)

# An alternative to split() is tidyr::nest()
tidyr::nest(x, -partition)

# You can also use bottom-left corners (or top-right or bottom-right)
bl_corners <- dplyr::filter(multiples, character == "Yes")
y <- partition(multiples, bl_corners, position = "bottom_left")
split(y, y$partition)

# If `partition_name` is already the name of a column in `cells`, then it
# will be silently overwritten
multiples$important_column <- "Will be overwritten"
partition(multiples, corners, partition_name = "important_column")
# Given a set of cells in rows 1 to 10, partition them at the 3rd, 5th and 7th
# rows. Row 3 is the top row of group 1.
partition_dim(1:10, c(3, 5, 7))

# Given a set of cells in columns 1 to 10, partition them at the 3rd, 5th and
# 7th column. Column 3 is the left-most column of group 1.
# This example is exactly the same as the previous one, to show that the
# function works the same way on columns as rows.
partition_dim(1:10, c(3, 5, 7))

# Given a set of cells in rows 1 to 10, partition them at the 3rd, 5th and
# 7th rows. Row 7 is the bottom row of group 1
partition_dim(1:10, c(3, 5, 7), bound = "lower")

# When the first row of cells is on the first cutpoint, there is no group 0.
partition_dim(1:10, c(1, 10))
partition_dim(1:10, c(1, 10), bound = "lower")

# Non-integer row/column numbers and cutpoints can be used, even though they
# make no sense in the context of partioning grids of cells.
partition_dim(1:10 - .5, c(3, 5, 7))
partition_dim(1:10, c(3, 5, 7) + 1.5)
}
